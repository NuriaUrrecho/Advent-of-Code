Este problema consistía en transformar una lista de números, denominados "piedras", mediante un conjunto de reglas iterativas durante un número determinado de "parpadeos". La solución requerida implicaba calcular el número final de elementos distintos generados tras todas las iteraciones. Hemos optado por modelar este proceso como un grafo dirigido, donde cada piedra es un nodo y las transformaciones representan los bordes. Esto nos permitió abordar el problema de manera estructurada y optimizarlo utilizando memoization, lo cual resulta clave para manejar el crecimiento exponencial de las transformaciones.

La función principal, transformarPiedra, aplica las reglas de transformación. Si el número tiene una longitud par, se divide en dos mitades, generando dos nuevos nodos. Si la longitud es impar, el número se multiplica por una constante y se genera un único nodo. Para evitar calcular varias veces las transformaciones de un mismo nodo, utilizamos una estructura de memoization, implementada mediante la clase Memo. Esta clase almacena los resultados de piedras ya procesadas, permitiendo reutilizar dichos resultados en iteraciones posteriores y reduciendo significativamente la complejidad computacional. Esto es especialmente relevante dado que la cantidad de nodos puede aumentar rápidamente con cada iteración.

La función transformarRecursivo gestiona todo el proceso de transformación a lo largo de los parpadeos. En cada iteración, generamos nuevos nodos a partir de los existentes y expandimos las conexiones del grafo según las reglas de transformación. Empleamos un arreglo dinámico para almacenar los nodos generados, asegurando que la memoria utilizada se ajuste al crecimiento exponencial del grafo. Una vez completadas las iteraciones, el tamaño del conjunto final de nodos representa la solución al problema. Además, nos aseguramos de manejar de manera adecuada los recursos asignados, liberando toda la memoria dinámica al finalizar el programa.

El uso de grafos nos permitió capturar de manera clara las relaciones entre las piedras y sus transformaciones, mientras que la memoization aseguró que las operaciones fueran eficientes, incluso para un número elevado de iteraciones. Al igual que en el día 10, realizamos una gestión adecuada de los recursos, liberando la memoria dinámica al finalizar el programa. Este enfoque combinó la representación explícita de las relaciones entre elementos con técnicas de optimización avanzadas, logrando resolver el problema de manera eficiente y dentro de los límites de tiempo establecidos.