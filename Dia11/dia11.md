Este problema consistía en transformar una lista de números, denominados "piedras", mediante un conjunto de reglas iterativas durante un número determinado de "parpadeos". La solución requerida implicaba calcular el número final de elementos distintos generados tras todas las iteraciones. Hemos optado por emplear programación dinámica, ya que esta técnica nos permitió optimizar los cálculos almacenando resultados intermedios y evitando la redundancia en los procesos de transformación. Desde el principio probamos con este método, ya que lo veíamos como el problema perfecto para utilizarlo, tras haberlo intentado en los días anteriores, y no haber podido.

La función principal, transformarPiedra, aplica las reglas de transformación a cada piedra. Si el número tiene una longitud par, se divide en dos mitades, generando dos nuevos resultados. Si la longitud es impar, el número se multiplica por una constante y se genera un único resultado. Para evitar calcular varias veces las transformaciones de un mismo valor, utilizamos una estructura de memoization, implementada mediante la clase Memo. Esta clase almacena los resultados de piedras ya procesadas, permitiendo reutilizar dichos resultados en iteraciones posteriores y reduciendo significativamente la complejidad computacional. Esto es especialmente relevante dado que el número de operaciones puede aumentar rápidamente con cada iteración.

La función transformarRecursivo gestiona todo el proceso de transformación a lo largo de los parpadeos. En cada iteración, expandimos las piedras generadas aplicando las reglas de transformación y almacenamos los resultados en estructuras dinámicas que se adaptan al crecimiento exponencial del conjunto. Además, empleamos memoization para reducir el número de cálculos duplicados, acelerando así el proceso general. Una vez completadas las iteraciones, el tamaño del conjunto final de resultados representa la solución al problema.

El uso de programación dinámica nos permitió capturar de manera clara las dependencias entre las transformaciones y almacenar los resultados intermedios, lo que asegura que las operaciones sean eficientes incluso para un número elevado de iteraciones. Al igual que en el día 10, realizamos una gestión adecuada de los recursos, liberando la memoria dinámica al finalizar el programa. Este enfoque combinó la optimización mediante memoization con una implementación escalable, logrando resolver el problema de manera eficiente y dentro de los límites de tiempo establecidos.

Una vez acabado el código, hemos reflexionado y nos ha ayudado mucho a aprender a manejar bien los arrays dinámicos y a recordar todo lo relacionado con las clases (constructores, destructores, etc.) y como manejarse con ellas.

Además, también hemos aprendido mucho de los problemas que tuvimos durante la programación ya que, aunque dominábamos bastante bien la programación dinámica y no tuvimos demasiados problemas en implementar el algoritmo, el resto del código se nos complicó en gran parte por el problema de la capacidad. Finalmente tuvimos que implementar un método para expandir la capacidad de la memoria, el cual tuvimos que aplicar cada vez que agregábamos una nueva entrada a la memoria.
