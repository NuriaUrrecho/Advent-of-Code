Este problema consistía en transformar una lista de números, denominados "piedras", mediante un conjunto de reglas iterativas durante un número determinado de "parpadeos". La solución requerida implicaba calcular el número final de elementos distintos generados tras todas las iteraciones. Hemos optado por emplear programación dinámica, ya que esta técnica nos permitió optimizar los cálculos almacenando resultados intermedios y evitando la redundancia en los procesos de transformación.

La función principal, transformarPiedra, aplica las reglas de transformación a cada piedra. Si el número tiene una longitud par, se divide en dos mitades, generando dos nuevos resultados. Si la longitud es impar, el número se multiplica por una constante y se genera un único resultado. Para evitar calcular varias veces las transformaciones de un mismo valor, utilizamos una estructura de memoization, implementada mediante la clase Memo. Esta clase almacena los resultados de piedras ya procesadas, permitiendo reutilizar dichos resultados en iteraciones posteriores y reduciendo significativamente la complejidad computacional. Esto es especialmente relevante dado que el número de operaciones puede aumentar rápidamente con cada iteración.

La función transformarRecursivo gestiona todo el proceso de transformación a lo largo de los parpadeos. En cada iteración, expandimos las piedras generadas aplicando las reglas de transformación y almacenamos los resultados en estructuras dinámicas que se adaptan al crecimiento exponencial del conjunto. Además, empleamos memoization para reducir el número de cálculos duplicados, acelerando así el proceso general. Una vez completadas las iteraciones, el tamaño del conjunto final de resultados representa la solución al problema.

El uso de programación dinámica nos permitió capturar de manera clara las dependencias entre las transformaciones y almacenar los resultados intermedios, lo que asegura que las operaciones sean eficientes incluso para un número elevado de iteraciones. Al igual que en el día 10, realizamos una gestión adecuada de los recursos, liberando la memoria dinámica al finalizar el programa. Este enfoque combinó la optimización mediante memoization con una implementación escalable, logrando resolver el problema de manera eficiente y dentro de los límites de tiempo establecidos.
