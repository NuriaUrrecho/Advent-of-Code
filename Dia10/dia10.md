Hemos elegido este problema porque calcular la puntuación total de senderos en un mapa topográfico plantea un reto ideal para aplicar técnicas basadas en grafos. La naturaleza del problema, donde se deben explorar rutas válidas que inician en posiciones de altura 0 y avanzan de manera estrictamente ascendente hasta alcanzar una altura de 9, requiere una solución estructurada y eficiente para manejar todas las posibles conexiones entre las posiciones del mapa.

El algoritmo que hemos empleado está basado en una representación de grafos, en la cual cada nodo del mapa corresponde a una celda con una altura determinada, y los bordes representan las transiciones válidas entre nodos adyacentes. La función principal, calcularSenderosDesdeNodo, comienza desde una coordenada inicial y explora todas las posibles rutas utilizando una búsqueda en anchura (BFS). Para evitar procesar varias veces el mismo nodo dentro de una ruta, utilizamos un unordered_set que almacena las coordenadas visitadas. Esto garantiza que las rutas sean únicas y evita la exploración redundante de caminos previamente procesados.

Dentro de esta función, verificamos tres condiciones fundamentales: que la posición destino esté dentro de los límites del mapa, que la altura de la posición destino sea exactamente un nivel superior a la actual y que la posición no haya sido visitada anteriormente. Cada vez que se alcanza una posición con altura 9, incrementamos un contador de senderos. Esto asegura que todas las rutas válidas sean contabilizadas y que el cálculo final refleje correctamente el número de caminos útiles para cada punto de partida.

La función calcularPuntajeTotalDeSenderos recorre el mapa completo y llama a calcularSenderosDesdeNodo desde cada posición inicial de altura 0, acumulando las puntuaciones de todos los senderos encontrados. Para manejar el mapa, utilizamos una matriz bidimensional asignada dinámicamente, permitiendo que el tamaño del grafo se adapte a cualquier entrada. Además, realizamos una correcta gestión de memoria, liberando los recursos asignados una vez calculado el puntaje total. Este enfoque asegura una solución eficiente y escalable, capaz de procesar mapas grandes sin incurrir en cálculos redundantes. Este planteamiento nos permitió resolver el problema dentro de los límites de tiempo esperados y garantizando un uso óptimo de recursos.

Tras la realización del código, podemos afirmar que nos ha servido mucho para comprender mucho más a fondo el funcionamiento de los grafos, con un código mucho más complejo y largo. Además, implementar el algoritmo BFS para explorar los nodos desde un punto de inicio también nos ha ayudado a entender mucho mejor el algoritmo.

Pero también encontramos varios puntos en los que tuvimos problemas y dudas para implementar el código. Por ejemplo, en un principio en vez de usar un unordered_set de strings, usamos una matriz booleana para marcar los nodos visitados, pero nos dimos cuenta de que esto requería mucho más espacio en memoria y no hubiese sido tan flexible.
También pensamos en emplear arreglos en vez de matrices dinámicas pero, teniendo en cuenta que no sabemos el tamaño del input, limitaba la flexibilidad del programa. Sin embargo, tuvimos muchos problemas a la hora de implementar las matrices con punteros int** y tuvimos que ser muy cuidadosos para que no hubieran errores en el código.
