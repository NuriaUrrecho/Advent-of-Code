Para este problema, necesitamos encontrar las ubicaciones de los antinodos (punto perfectamente alineado con dos antenas que emiten la misma frecuencia). Para ello, hemos decidido emplear tablas Hash, ya que era la estructura más eficiente y sencilla para manejar los antinodos y los mapas, reduciendo así la complejidad del código y consiguiendo realizar operaciones de inserción y búsqueda de una forma mucho más efectiva.

Para ello, tenemos que encontrar puntos colineales con dos antenas, comprobará si ese punto está al doble de distancia de una antena que, de la otra, y contar las posiciones que cumplen dichas condiciones.
Lo primero que hemos hecho es declarar una estructura, en la que hemos definido las características de las ANTENAS, es decir su coordenada (x, y) y la frecuencia que emite.
Lo siguiente ha sido crear una función para calcular la distancia entre dos puntos (distanciaManhattan). Esta simplemente devuelve la distancia, siendo esta la suma de la diferencia entre las dos variables de las coordenadas, en valor absoluto, ya que estamos hablando de distancias.
Después, hemos implementado una función que devuelva True si son colineales los puntos, y False en caso contrario (sonColineales). Básicamente hemos comprobado que la pendiente entre P1 y P2, fuera la misma que P2 y P3. Al principio nos daba un desbordamiento, al ejecutar el programa, hemos debido tener en cuenta que las multiplicaciones podían darnos un número mucho más grande que lo que soporta un int, y por eso hemos transformado los datos a long long.

Para el problema final creamos una función que encuentre los Antinodos. Para eso, hemos creado un espacio en memoria que contenga un vector de Antenas, que sea tan grande como puntos haya en la cuadrícula, para ir guardando los puntos hemos recorrido la cuadricula y cuando el valor era alfanumérico (isalnum; función consultada en cplusplus.com), guardábamos la antena como estructura que contenía el valor x e y en el que se encontraba el programa y el valor de esa coordenada (cuadrilla[x][y]).
Se ha iniciado una tabla hash con unordered_set (página 18 de los apuntes), y hemos pasado a comprobar posibles puntos que cumplieran las condiciones. Cuando se encontraban dos antenas con la misma frecuencia, se calcula el vector en x y en y, y las guardamos como posibles opciones a que haya un antinodo (antes de la primera antena y otro después de la segunda. Verificamos que el punto este dentro del mapa, si son colineales, y por último si cumple la condición de resonancia, si todo esto se cumple se añade el antinodo a la tabla hash. Al final de la función devolvemos el tamaño de la tabla hash, es decir, el número de ubicaciones únicas.

Hemos utilizado la tabla hash para asegurar que cada antinodo se guarda una sola vez, y además la búsqueda e inserción será rápida.

Por último, en el main hemos cargado el archivo, y hemos llamado a la función encontrarAntinodos. También hemos eliminado el espacio en memoria reservado para la cuadrilla, como buena praxis.

Este código nos ha enseñado a usar muchas funciones que desconocíamos. En primer lugar, encontramos la librería <unordered_set> en los apuntes de la asignatura, la cual aprendimos a usar y nos resultó muuy útil a la hora de almacenar las ubicaciones únicas de antinodos, ya que esta librería elimina automáticamente los duplicados. También investigamos y aprendimos otras funciones como isalnum() y a manejar tablas hash y cubetas en general.

Pero, tuvimos algunos problemas al implementar funciones como bool sonColineales, ya que nos costó llegar a la fórmula correcta. Además, en un principio no pensamos en usar unordered_set y optamos por almacenar las ubicaciones de los antinodos en un array, lo cual era mucho más costoso y menos eficiente, ya que hubieramos tenido que verificar manualmente si una ubicación ya estaba presente en la lista, especialmente con un número de antinodos tan grande como los del input.
